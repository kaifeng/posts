---
layout: post
title: XLR732从核加载与实践
author: kaifeng
date: 2009-06-24
categories: bsp
---

本文简要介绍了XLR732多核处理器的消息环机制，重点阐述软件在基于该处理器的单板上所实现的从核加载过程，最后以一个实例分析了加载过程中所出现的故障及解决方法。

## 概述

XLR732是RMI公司推出的一款MIPS多核处理器，它集成了8个内核，每个核可支持4个硬件线程。

由于VxWorks5.5操作系统尚不支持SMP，软件只能以AMP方式运行，每个核都运行一套独立的操作系统。而由于硬件资源有限，软件在AMP方式下，不太可能采用各线程同时启动的方式，线程之间的同步，硬件资源由谁来初始化，这些都是问题。因此，软件首先启动一个线程，在软硬件初始化完毕后，再对其它核进行映像加载，这个加载过程称为从核加载过程。

从核加载的总体思想比较简单，就是将从核映像拷贝到物理内存相应位置，并根据ELF的头信息为从核计算对应的TLB映射关系，这里使用了处理器的扩展，所以 我们首先对处理器的消息环FMN做一个简要介绍，然后介绍从核加载涉及的各个方面的内容。从核加载是重要的，一旦加载失败，从核将无法工作，本文最后介绍了曾经出现的一个从核加载失败的故障解决情况，为今后的类似现象提供解决思路。

## 从核加载

### XLR的消息环机制

XLR的消息环简称FMN（Fast Messaging Network），是一个64位的环形单向通路，它为CPU核之间及CPU核与其它重要部件提供了一种通信机制。图1是XLR消息环的示意图。

![XLR消息环](/posts/assets/xlr-ampboot-msgring.png)

图1：XLR消息环

在这个环状网络上，存在13个称作FMN站点的部件与之连接，提供消息收发功能。FMN工作在核时钟频率，在时钟的驱动下，消息从一个站点向下一个站点传递。从图中可以看到，8个核都有对应的FMN站点，剩下的5个站点其中3个分配给了网络加速器，另2个分别分配给SAE和DMA。每一个站点包含一个接收队列，队列大小为256项。队列被划分为大小可编程的桶，每个桶都有唯一的全局固定编号，这个编号即为消息发送的目的地址。

消息的基本单位称为一个entry（64位数据），一次最多可以发送4个entry，并携带8位的SW Code，用于自定义消息的类型。CPU 核的消息收发是通过COP2及扩展指令实现的。接收消息时，CPU核使用MSGLD扩展指令从指定Bucket中取一个消息至线程的COP2寄存器，然后 使用mfc2指令将数据从协处理器中取出。需要发送消息时，CPU核先将消息写入COP2寄存器，然后使用MSGSND指令将消息发送到消息环。COP2 也提供了状态寄存器用于告知消息是否发送成功，是否有消息到来等各类信息。

### 主核启动及内存映射

在BOOT阶段，每个线程通过COP0读到当前核及线程的编号，仅有核0的第1个线程向后执行，完成与单核CPU相同的工作，如进行内存配置，硬件初始化等工作并加载引导映像。其它所有线程通过扩展指令MSGWAIT守候各自的Bucket等待主核的通知消息。

需要提及的是，核1-7在CPU复位后，默认处于复位态。由于主核会在sysHwInit对Local Bus进行重新配置，使得BOOTFLASH地址发生了改变，需要配置一段物理内存至0x1fc00000开始的区域（注：XLR732支持物理内存地址段的配置），然后将BOOT拷贝至这个MIPS默认的启动地址区域。BSP在启动的最后将复位状态解除，从核开始从RAM运行BOOT代码。

![内存布局](/posts/assets/xlr-ampboot-memlayout.png)

图2：内存布局

主核启动后，加载从核前的内存运行环境如图2所示。图中箭头代表一对TLB映射，将对应的虚拟地址映射为物理地址。可以看到，从核的运行空间安排在 0x20000000-0x60000000之间的1G区域。为了将从核映像拷贝到这段空间，主核必须添加相应TLB表项（蓝色箭头标识），在加载完从核后，主核这段虚拟地址空间要重新映射回最终的位置，供业务使用（黑色箭头标识）。

### ELF解析及TLB计算

#### ELF头信息解析

ELF 文件提供了两个平行的视图用于表示目标文件的内容，即链接视图和执行视图。链接视图的信息由Section Header Table提供，链接器根据文件内的section信息进行符号解析及重定位。执行视图的信息由Program Header Table提供，解析从核的ELF信息，也就是解析ELF头信息中提供的Program Header信息，其结构定义如下:

```
typedef struct {
    Elf32_Word p_type;
    Elf32_Off p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    Elf32_Word p_filesz;
    Elf32_Word p_memsz;
    Elf32_Word p_flags;
    Elf32_Word p_align;
} Elf32_Phdr;
```

p_type表示该段的类型。一般取值为PT_LOAD，表示一个可加载的段，PT_NULL则表示该段不使用。

段在内存中的分布信息由p_vaddr和p_memsz提供，分别表示了该段在内存中的起始地址及占用的大小。

段在文件中的分布信息则由p_offset和p_filesz提供，分别表示了该段在elf文件中的偏移起始及数据长度。

p_flags为段标志位组合，PF_X表示可执行的段，PF_R和PF_W则分别表示可读和可写。

p_align表示边界对齐要求，如该值为0x1000表示段需要在4k边界开始。

#### TLB计算

MIPS的TLB配置存储在COP0寄存器中，通过特有的TLB读写指令访问。一个TLB条目保存在4个寄存器中：EntryHi、EntryLo0、EntryLo1和PageMask。TLB结构在逻辑上可分为两个部分：比较部分和物理翻译部分。 EntryHi中的VPN2用于配置虚拟地址，属于TLB的比较部分，EntryLo0和EntryLo1中的PFN用于配置物理地址，属于TLB的物理翻译部分，PageMask指定VPN2中的哪些低位不参与地址匹配，也就控制了页面的大小。MIPS的特殊之处在于一个虚拟地址条目对应两个物理地址条目，假设PageMask将一页设为256M，VPN2将映射512M的虚拟地址范围，EntryLo0和EntryLo1相应地各映射256M物理地址。XLR732支持MIPS定义的4K~256M范围的页面大小（注：页面大小以4的倍数增长，依次为：4K, 16K, 64K, 256K, 1M, 4M, 16M, 64M, 256M）。 TLB 以页表方式映射，这要求每个TLB条目都必须是以页边界对齐的，这引入了一个较为苛刻的条件，即TLB的物理地址部分必须是页大小对齐，TLB的虚拟地址 部分必须是2倍页大小对齐，越是大的页，对齐的要求越不容易满足。而MIPS与其它处理器不同，内存中并不存在一个页表来存储TLB条目，而是存储在 COP0中，因此其资源也是非常有限的（注：XLR732每核提供64个TLB条目，在同时启用4个线程的情况下，每个线程只能使用16个TLB条目）。

TLB计算是从核加载的主要内容，主要流程为：

1. 解析段的p_vaddr和p_memsz。在初始条件下，未映射区域的大小即为p_memsz。
2. 按当前虚拟地址、物理地址及未映射区域的大小，计算最佳的TLB页大小。
3. 根据算出的页大小，及当前的虚拟地址，物理地址，形成一个TLB条目保存。
4. 根据第2步得到的页大小，更新未映射区域的大小，虚拟地址及物理地址，重复第2步。如果段数据已全部映射，则继续解析下一个段的数据，重复这一过程。

在计算出一个段的TLB条目后，主核将段数据拷贝至对应的物理内存位置，完成数据的实际加载工作。

从上述流程可以看到，主要工作在第2步，即计算最佳的TLB页大小，其主要实现如下:
```
for (i = 8, pass = 0; i >= 4; --i, pass = 0) {
    pass += ((virt_addr % (2 * tlb_page_size_list[i])) == 0);
    pass += ((phy_addr % tlb_page_size_list[i]) == 0);
    pass += (size >= (2 * tlb_page_size_list[i]));
    if (pass == 3) {
        return tlb_page_size_list[i];
    }
}
```

phy_addr表示物理地址，它从0x20000000开始增长，顺序存放解析出的段数据。virt_addr 即为elf信息中的p_vaddr，size为待映射的数据大小。tlb_page_size_list是一个数组，存放从4K至256M范围的各种页大小。从代码中可以看出有三个条件必须满足：（1）虚拟地址必须是页大小的2倍边界对齐；（2）当前物理地址必须是页大小边界对齐；（3）所选择的页大小产生的映射区域不大于未映射区域。前两个条件是MIPS架构所限，而第三个条件，则暗示了选择的策略。

页大小的匹配，有两种策略：

1. 分配小于待映射区域的最大页，即以逼近的方式去匹配。这种分配方式对内存的浪费最小，但却非常耗费TLB条目，在极端的情况下，甚至用掉所有的TLB还不能完成映射。举例来说，假如有9428992字节（9M-8K）这样大小的段，即使不考虑对齐，也需要耗费20个TLB条目，表1给出了依次分配的过程。
2. 分配大于待映射区域的最小页。这种方式则与第1种方式正好相反，虽然节省了TLB条目，但对内存地址会有很大的浪费。仍然举例说明，对一个大小为8M+8K 的段，虽然只需要花费两个8M的TLB条目，但其中一个8M映射实际只使用了4K，随着分配页面的增大，浪费也会增加，而因对齐要求产生的空间浪费会更多。

分配策略举例
```
待分配空间  TLB分配空间（2倍页大小）  剩余空间
9M-8K      8M                    1016K
1016K      512K                  504K
504K       32K                   472K
472K       32K                   440K
440K       32K                   408K
408K       32K                   376K
376K       32K                   344K
344K       32K                   312K
312K       32K                   280K
280K       32K                   248K
248K       32K                   216K
216K       32K                   184K
184K       32K                   152K
152K       32K                   120K
120K       32K                   88K
88K        32K                   56K
56K        32K                   24K
24K        8K                    16K
16K        8K                    8K
8K         8K                    0K
```

上表示例了两种分配策略的结果。可见，两种方法都有明显的缺点，没有哪种更优，这的确是一个困难的选择。我们的代码使用了第1种策略，一方面是因为从核运行空间的限制（注：从核运行空间为1G，在业务提出扩大共享内存的需求后，又减少了256M。核1映像的数据段有256M，每个媒体面核的数据段有16M，由于TLB的硬性对齐要求，TLB条目之间会存在一些无法利用的空洞），另一方面也是为了提高空间利用率。那么如何解决TLB不够用的问题呢？这个问题其实没有彻底的解决办法（资源永远都是有限的），但我们可以通过提高最低分配页面的大小来极大地缓解它的出现。从代码中我们可以看到，循环条件的i最小为4，即代表最小的页面空间为1M，这其实就是分配效率与空间利用之间的折衷处理。将最小页面空间提高到1M，使得剩余分配空间必须是2M的整数倍，这就要求p\_memsz也必须是2M的整数倍，好在可以通过链接脚本来处理这个问题（注：如在data段最后加上 `. = ALIGN(0x200000)` 将使data段对齐到2M边界结束）。经过对齐处理后，9M-8K这样的段大小被对齐到10M，只需要两条TLB即可完成映射，每个条目的空间浪费不会超过2M。

### 从核的TLB配置

主核在完成TLB计算，并将映像段数据拷贝至物理内存后，剩下的工作就是从核自身的TLB条目配置了。由于各核的COP0是独立的，主核无法直接修改从核的TLB配置，因此这个工作只能由从核自己来完成。但是主核计算出的TLB条目如何告知给从核呢？这就要用到XLR的消息环机制了。我们在前面中提到，在主核加载从核之前，从核是处于等待消息的状态。主从的交互流程如图3。

![图3：主从交互流程](/posts/assets/xlr-ampboot-workflow.png)

图3：主从交互流程

主核在进行从核加载初始化时，调用wakeup_cpu向从核发送消息，消息携带入口函数smp_init_secondary，从核收到消息后直接跳转到这个函数开始执行，主要进行一些初始化操作，并清空COP0中的所有TLB条目，执行完毕后继续等待消息。

主核在完成TLB计算和映像数据拷贝后，再次发送消息给从核，携带入口函数bootstrap_psb_os_helper，从核再次直接跳转到这个函数执行，这个函数的主要工作就是将主核在TLB计算阶段保存下的条目配置，配置进本核的COP0寄存器中(注：由于TLB配置是4个线程共用的，因此只能有一个线程进行这个操作），完成后，跳转到映像的入口开始执行，从核加载流程即宣告结束。

这里有两个巧妙的设计：

1. 从核如何能执行主核的代码？在MIPS的架构里，KSEG0段是永远映射在物理地址的前512M空间的。因此无论在哪个核上访问KSEG0空间，都是在访问同一段物理地址。因为核0运行在KSEG0段前256M，因此其代码和数据实际存放在物理地址0~256M范围，从核可以通过KSEG0段访问到核0的代码和数据。因此从核跳转至smp_init_secondary和bootstrap_psb_os_helper也是在执行主核的代码。从核将主核计算出的TLB配置写入COP0，使用的是保存在cpu_wakeup_info结构数组中的信息，这是主核的一个全局结构数组，同样也是可以访问的。
2. 从核在BOOT阶段，还没有建立C语言环境，如何能运行主核的C代码呢？这是因为主核在调用wakeup_cpu向从核发送消息时，除了入口函数和一个可选参数外，还携带了一个gp指针初值和sp指针初值，供从核设置gp和sp指针。从核在收到主核发来的消息后，先根据消息中的gp和sp值设置寄存器，建立C语言运行环境，然后跳转到指定入口执行。从核运行主核代码时的临时堆栈和全局数据区由主核提供，在实现上就是主核的一个全局数组，一部分用于堆栈，一部分用于全局数据区，并以此设置指针，其空间分布如图4所示。

![图4：临时堆栈区](/posts/assets/xlr-ampboot-tmpstack.png)

图4：临时堆栈区

## 从核加载的故障

在2008年8月份多次出现了因TLB不够用而导致的从核加载失败故障。这个故障与特定大小的从核版本有关，而且主要在加载核1版本时出现，此前偶尔出现过，但是一直没有好的方法解决。核1的数据段有256M（注：此处的数据段指除代码外的section总和，包括.data, .bss和.stack。其大小由软件写死为256M，编译期的实际段大小远小于该值，多余的部分作为堆空间使用），这是一个很大的段，在TLB计算时，确实会有可能出现恶化的情况。

为什么与特定大小的从核版本有关？这是因为核1的版本有两个段，一个是代码段，另一个是数据段，从核加载是按段的顺序依次加载的，由于代码段随着新增代码的引入，不断发生着变化，其总体趋势也是增长的，数据段在代码段之后加载，因而其存放物理地址也随着代码段的变化而浮动。代码段是一个较小的段，一般只有几兆大小，但是它的浮动，对后续256M的数据段产生了对齐的影响，假设代码段结束在0x20200000，那么按照的对齐要求，在这个物理地址上只能使用一个1M的页面来映射（非4M边界对齐），在使用了两个1M页面后，物理地址在0x20400000，才能使用4M的页面，这样就已经耗费了三个TLB条目，而所映射的区域也只是(1M+1M+4M)*2=12M而已（注：从页面的整个匹配过程来说，头尾两段空间耗费TLB条目较多，头部受到对齐影响，尾部则是受到逼近算法的影响），对于256M数据段，还有相当大一部分没有映射。

为了消除代码段变化对后续数据段加载的影响，使每次加载都能有一个确定的结果，一个直观的思路就是将代码段和数据段合二为一。因为从核加载是按照Program Header表中的条目一项项解析的，如果代码和数据段合并在一个Program Header条目中，对于固定的空间大小，TLB计算的结果也是固定的。这就要求我们能够控制Program Header的生成，链接脚本提供了这一能力。

链接脚本用于定制Program Header的命令语法如下:
```
PHDRS
{
  name type [FILEHDR] [PHDRS] [AT (address)] [FLAGS (flags)];
}
```

name为该条目定义了一个名字以便于引用，不输出到目标文件，type则指定Elf32_Phdr的p_type字段。其它均为可选项，用于进一步定制条目的内容，由于我们不使用这些字段，此处便不再赘述，进一步了解可参阅文献[5]。在定义了Program Header后，将哪些Section放入哪一个Program Header则以 `.section:{…}:name` 的形式标注。由于我们只需要一个Program Header，使用PHDRS定义一个段如下:
```
PHDRS
{
  ph_cd PT_LOAD;
}
```

然后在代码段之后加入 `:ph_cd` 指示链接器将text段放入ph_cd这个段：`.text:{…}:ph\_cd`。

对一个用:name限定的section之后的section，如果不使用:name，则默认使用上一个section的设置，这样就无需对所有section都进行这样的处理了。使用readelf工具查看编译生成的ELF头信息，Program Header确实已经按我们定制的方式生成了。

修改前:
```
Program Header:
Type  Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
LOAD  0x001000 0x00200000 0x00200000 0x200000 0x200000 R E 0x1000
LOAD  0x201000 0x00400000 0x00400000 0x503d0 0xa00000 RW  0x1000
```

修改后:

```
Program Header:
Type       Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
LOAD       0x001000 0x00200000 0x00200000 0x2503d0 0xc00000 RWE 0x1000
```

这种修改方法简单直接，不会产生未预料的结果，对从核加载的稳定性尤为重要，同时也不影响加载流程，免于引入特殊的处理代码。当然它也有明显的缺点，就是两段合一后不能再单独对代码段进行保护。由于此前的实现也没有加入代码段的保护，因此在实践中我们采用了这个方法。对于需要作代码段保护的情形，可以考虑先加载大的数据段，再加载代码段，或者给代码段一个固定大小的空间，并保证代码不会超过这个大小来避免代码段的浮动影响，这些都需要对加载流程进行一定的修改。

## 总结

本文首先介绍了XLR多核处理器的消息环机制，对从核加载的主要流程及相关技术点进行了说明，涉及了MIPS架构与ELF相关的内容，最后介绍了有关故障的 解决情况。多核处理器是今后的发展方向，MIPS以及硬件设计的简洁性也越来越多地出现在嵌入式领域，随着应用范围的不断扩大，也将会有越来越多的思考和问题等待着我们。从核加载流程在以AMP方式运行的系统环境中具备一定的典型性，愿本文能在这一方面起到抛砖引玉的作用。

## 参考资料

[1] RMI Corporation, XLR Processor Family Programming Reference Manual, Revision3.0, Jan 2008.

[2] MIPS, MIPS64 Architecture for Programmers Volume III - The MIPS64 Privileged Resource Architecture v2.50, July 2005.

[3] Dominic Sweetman, MIPS体系结构透视(英文版.第2版)，机械工业出版社，2007年2月。

[4] TIS Committee, Tool Interface Standard(TIS) Executable and Linking Format(ELF) Specification Version 1.2, May 1995.

[5] FSF, Using ld, the GNU linker, ld version 2, Jan 1994.