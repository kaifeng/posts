---
layout: post
title: ARM JTAG烧结原理与实现
author: kaifeng
date: 2008-06-24
categories: bsp
---

## 概述

ATMEL91是一款ARM SoC，使用的是ARM7TDMI的ARM核，型号为AT91FR40162S。CPU内部集成了一片2M的FLASH，用于存放boot，这块FLASH从外部无法直接访问。

烧结ARM片内Flash的工具比较多，但大多数都不成熟或者不完整，除去厂商支持的工具外，HJTAG是一个可用的工具。HJTAG虽然不开放源代码，但其网站也提供了一些资料，介绍了一些基本的概念和原理，这也是本文工作的起点。比较重要的两份资料是HJTAG作者写的《ARM JTAG调试原理》和ARM公司的《ARM7TDMI Technical Reference Manual》。

这个工作的重点在于两个地方：首先就是通过JTAG控制ARM，其次是JTAG链管理。由于开发时间的关系，JTAG链管理的实现则相对简单。

在查阅了一定的资料后，大致确定了烧结方法：通过JTAG下载一段程序进入ARM的SRAM，烧结数据也通过同样的方式下载到SRAM的固定位置，然后运行ARM内的代理程序来烧结FLASH。我们通过点灯的方式验证了通过JTAG将程序下载至ARM内是可以正常运行的，然后就开始设计方案了。

在描述具体实现前，先看看烧结的原理与技术基础。

## ARM JTAG调试原理

### 边界扫描链

通过JTAG控制的三条边界扫描链是我们与ARM核交互的唯一接口，ARM7TDMI提供了3条边界扫描链供调试使用，如图1所示。
  
扫描链0可以访问ARM7TDMI核的所有外围线路，包括：32位数据信号，核控制信号，32位地址信号，EmbeddedICE-RT控制信号。链长度为113位，主要用于EXTEST和INTEST。我们的功能不需要使用这个扫描链。

扫描链1是扫描链0的子集，包括32位数据总线及BREAKPT位，因此链长为33位，主要用于调试。扫描链1比扫描链0要短得多，虽然我们也能通过扫描链0来控制地址线与数据线，但在速度上将会慢很多。不论是数据还是指令，都需要通过数据线访问，因此，我们可以通过这条链向流水线插入指令和数据。

扫描链2围绕EmbeddedICE-RT逻辑（为ARM7TDMI提供了集成的芯片级调试支持），用于访问ICE的寄存器。链长为38位。这个嵌入调试器包含了一些寄存器用于调试，让我们可以控制调试状态，设置断点和观察点。除了在设置调试模式外，控制访问DCC通道也需要通过这个寄存器。DCC通道（调试通讯通道）是在后面的实现中大幅提高烧结速度所依赖的一个重要特性。至于断点及观察点设置，则与我们的烧结功能无关，不会用到。

![ARM7TDMI边界扫描链](/posts/assets/arm-jtag-1.png)

图1：ARM7TDMI边界扫描链

### 内核时钟

ARM7TDMI有两个时钟，一个是内存时钟MCLK，一个是TCK产生的时钟DCLK。在正常模式下，核由MCLK驱动，当ARM进入调试状态时，由DCLK驱动，而DCLK又受到TAP状态机的控制，因此我们能控制ARM单步执行以及完成指令插入工作。

ARM进入调试模式时，必须由MCLK切换到DCLK，这是由ARM核自动完成的。在ARM退出调试模式时，内核同步回MCLK。我们需要完成两个操作来退出调试模式：（1）最后一条移入指令的BREAKPT必须置位，表示让指令以系统速度运行。（2）移入RESTART使ARM退出调试模式。
如果DBGREQ仍为1，那么ARM将以MCLK时钟运行一条指令并再度返回调试模式。由于内存访问需要MCLK时钟，这个特性使得我们能够利用它来执行一些内存访问指令。

### JTAG指令

ARM7TDMI的指令寄存器长度为4位，表1列出了公开的JTAG指令。

表1：JTAG公开指令
```
指令            指令编码
EXTEST          0000
SCAN_N          0010
SAMPLE/PRELOAD  0011
RESTART         0100
CLAMP           0101
HIGHZ           0111
CLAMPZ          1001
INTEST          1100
IDCODE          1110
BYPASS          1111
```

ARM7TDMI默认选择扫描链3，SCAN_N指令可用来重新选择边界扫描链。在系统模式下，扫描链0和1是不能选择的，扫描链2没有该限制。

RESTART指令将使ARM核退出调试状态。还有一点需要格外注意的是，当TAP进入TLR时，ARM也会离开调试状态，编码时忽略了这一点，导致调试时花了很长时间才找到原因。因此一个连续的操作过程中，我们不要让TAP进入TLR状态。

INTEST指令将ARM置于测试状态，也是我们需要使用的指令。

我们使用IDCODE指令用来判断是否为目标单板，其它指令则不使用。

### 访问ICE寄存器

ARM7TDMI提供3个附加的调试信号：DBGRQ、DBGACK和BREAKPT，这三个信号都可以通过ICE寄存器控制：

DBGREQ是调试请求信号，通过把该信号置1，可以使ARM进入调试状态。
DBGACK是调试状态位，读取它可以判断当前ARM是否处于调试状态。
BREAKPT是断点信号，如果该信号置1，当前的内存访问被设置为断点。如果当前内存访问是取指，则指令执行时，ARM自动进入调试状态，如果当前的内存访问是存取数据，在存储完成后，ARM自动进入调试状态。

通过扫描链2，可以访问的EmbeddedICE-RT寄存器如表2：

表2：EmbeddedICE-RT寄存器
```
寄存器地址  寄存器宽度	功能
00000      6        Debug Control
00001      5        Debug Status
00010      1        Abort status
00100      6        Debug comms control register
00101      32       Debug comms data register
01000      32       Watchpoint 0 address value
01001      32       Watchpoint 0 address mask
01010      32       Watchpoint 0 data value
01011      32       Watchpoint 0 data mask
01100      9        Watchpoint 0 control value
01101      8        Watchpoint 0 control mask
10000      32       Watchpoint 1 address value
10001      32       Watchpoint 1 address mask
10010      32       Watchpoint 1 data value
10011      32       Watchpoint 1 data mask
10100      9        Watchpoint 1 control value
10101      8        Watchpoint 1 control mask
```

扫描链2的数据定义如图2，38位的链由32位数据位，5位寄存器地址位，1位读/写标志位组成。

![ARM7TDMI边界扫描链2](/posts/assets/arm-jtag-2.png)

图2：ARM7TDMI边界扫描链2

通过这个定义，我们能根据寄存器地址及数据形成链数据，并移入扫描链。不论ARM处于调试状态还是系统状态，我们都可以访问这个链，即使核在系统状态下，我们访问这个链也不会影响系统内部的正常运行。

其中，Debug Control寄存器有6位，定义如表3：

表3：EmbeddedICE-RT Debug Control寄存器
```
bit5  ICE disable
bit4  Monitor mode enable
bit3  SBZ/RAZ
bit2  INTDIS
bit1  DBGRQ
bit0  DBGACK
```

将bit1的DBGRQ置1可以使ARM进入调试模式。通过设置断点或者Watchpoint也可以使ARM进入调试状态，但不如这种方法直接。

Debug Status寄存器含有DBGACK的信号状态，我们也用它来判断ARM是否处于调试状态。

如前面所述，断点等功能我们烧结功能不需要用到，因此这里不作介绍。

### 向流水线插入指令

前面提到ARM核有两个时钟，调试模式下以DCLK时钟运行，因为ARM7TDMI核是完全静态的，因此以低于正常速度的调试速度运行是可行的，不过调试状态下可以执行的指令有一定的限制，只有下列指令才能在调试状态下执行：

* 数据处理操作
* load, store, load multiple, store multiple指令
* MSR和MRS

前面说到我们可以以MCLK来运行一条指令，我们向流水线插入指令其实只需要加载存储指令就可以完成。在讲指令插入前，我们简单了解一下ARM7TDMI的流水线。

ARM7TDMI采用的是3级流水线，因此指令的执行分为3阶段，如图3所示：

![ARM7TDMI流水线](/posts/assets/arm-jtag-3.png)

图3：ARM7TDMI流水线

流水线以我们所熟知的方式工作：第一条指令被执行时，它的下一条指令正在解码，下下一条指令则正在从内存获取。程序计数器（PC）指向正在获取的指令，而不是正在执行的指令，因此正在执行的指令使用的PC是与它相差两个指令的地址。这一点看上去与我们关系不大，不过当我们计算PC时需要考虑到这个特性。

在离开调试模式时，我们需要给PC设置一个值，在ARM7TDMI技术手册中说明了如何计算返回地址：
* 从断点或者观察点返回：4+N+3S
* 从DBGRQ返回：3+N+3S

N为调试速度下执行的指令数，包括最后的跳转，S是系统速度下执行的指令数。
下面的伪码演示了一个内存写操作：
```
SelectChain(1);
ScanDR(0xE8900003);     // LDMIA R0, {R0,R1}
ScanDR(0xE1A00000);     // NOP
ScanDR(0xE1A00000);     // NOP
ScanDR((UINT32) addr);
ScanDR((UINT32) data);
ScanDR(0xE1A00000);     // NOP
ScanDR(0xE5801000);     // STR R1,[R0]
```

这段伪码以JTAG操作的形式描述，SelectChain是指选择扫描链1，ScanDR则是向扫描链移入数据。

因为取指是通过数据总线进行的，第2行将0xE8900003移入DR，即相当于使ARM取到指令LDMIA R0, {R0, R1}，这条指令的作用是：R0=[R0], R1=[R0+4]。

第3行插入NOP指令时，LDM指令进入译指阶段，在第4行进入执行阶段第一周期。第一周期为地址计算，第二个执行周期从内存取[R0]的值，因此在第5行将addr放至数据总线上，第三个执行周期从内存取[R0+4]的值，代码在第6行将data放至数据总线上，第四个执行周期LDM将读取到的值存入R1，指令执行至此结束，R0=addr，R1=data。第8行的指令将R1中的数值data写入addr地址处，完成写操作。

可以看到，我们写入的指令都是具体的机器码，我们只要把需要的指令汇编再反汇编后就可以得到对应指令的机器码，因为我们需要的存储加载指令数量不多，因此这个工作量很小，而具体指令执行需要的周期可以从ARM架构手册中查到。

## 烧结实现

从前面的写内存伪码可以看到，写内存需要JTAG作7次扫描，直接写内存是非常慢的，因此采用下载程序进入ARM内存再执行烧结的方式，烧结数据也是通过同样的方式下载进内存指定位置，当下载完毕后，启动烧结程序进行烧结。

下载程序姑且称之为Flash Walker吧，它分为两部分，如图4：

![ARM7TDMI烧结流程设计](/posts/assets/arm-jtag-4.png)

图4：ARM7TDMI烧结流程设计

Init.s是平台相关代码，这个平台相关不是指体系结构相关，而是指单板相关。FlashWalker.c则是具体的Flash驱动，这样的设计可以使Flash烧结部分能得到重用。

Loader主要完成堆栈的初始化和参数的配置，但不进行空间重映射操作，因为烧写程序在将FlashWalker传入内存时，必须知道内存段的确切位置。映射操作及初始化操作另由烧结程序向寄存器写入配置完成。

我们知道，程序编译后，它的各段地址空间就确定了，通常我们使用编译器默认的空间排列是没有问题的，但对于下载进入ARM的程序，我们必须修改链接脚本以适应需要。

下面的脚本是告诉链接器，我们单板片内的内存分布情况：
```
MEMORY
{
    ram       : ORIGIN = 0x00000000, LENGTH = 8K
    octavia   : ORIGIN = 0x00002000, LENGTH = 256K - 8K
}
```

通过将所有段置于ram区，可以将烧结程序限制在0~8K的区域，这样我们将烧结数据写入0x2000地址也不会影响程序的运行环境。如果烧结程序膨胀超过8K，这个参数我们还可以调整。下面是一个将堆栈段放入ram的例子：
```
.bss :
     {
          __bss_beg__ = .;
          *(.bss)
          __bss_end__ = .;
     } >ram
```

__bss_end__这个宏我们在init.s中使用，用来初始化堆栈指针。

同时，我们还应注意到单板的一个限制，就是SRAM只有256K，如果烧结数据超过了256K~8K，那么是无法烧结的。当然，我们可以通过将烧结数据分段来解决这个问题，但是后面我们可以看到有更好的方法。

按照该设计实现，对于十来K的BOOT而言，倒还可以接受，烧结时间在十几秒，但随着内容的不断添加，烧结程序一次性就需要烧结200k以上的数据，这个烧结速度就让人无法接受了，版本烧结时间大约在五分钟左右。

ARM7TDMI技术手册描述了一个调试通道，它是仿真器用来与ARM核交互的通道，最初的方案设计里，我们只是用它来返回烧结状态，并没有通过它来传递数据。我们将改造最初的FlashWalker和烧结程序，让他们用DCC通道来传递烧结数据以加快烧结速度。

DCC也即Debug Communication Channel，前面我们在ICE寄存器中已经看到了它的身影。DCC实际上有3个寄存器，但是始终只能操作2个，读写寄存器逻辑上合为一体。DCC包含一个32位的数据读取寄存器，一个32位的数据写入寄存器和一个32位的控制寄存器。控制寄存器提供用于实现两端的握手的协议，这个协议是自定义的。在ARM侧可以通过协处理器指令MCR/MRC访问DCC寄存器，烧结程序侧可以通过扫描链2访问。图5是控制寄存器的定义。

![DCC控制寄存器](/posts/assets/arm-jtag-5.png)

图5：DCC控制寄存器

我们关心的是低2位，要注意这里所说的读写是针对ARM核方向而言的，对于JTAG侧则是相反的（读对应写，写对应读）。

Bit1：当该位为0时，表明ARM可以向DCC数据写入寄存器写入数据，如果该位为1，表明DCC数据写入寄存器有数据，JTAG侧可以将它扫描出去（当然也同时表明ARM不能再往写入寄存器写入数据）。

Bit0：当该位为0时，JTAG侧可以向DCC读取寄存器写入数据，当该位为1时，ARM侧可以从读取寄存器读出数据（当然也同时表明JTAG不能向该寄存器扫入数据）。

改用DCC传送数据后，我们的烧结流程就有比较大的改动。最终的流程是这样的：

1. 配置ARM寄存器，为烧结程序提供一个稳定的环境。这里主要是配置片选及映射，将FLASH映射到0x01000000处，SRAM则映射到0地址处，还有EPLD的配置，并闭看门狗及Flash保护等操作。
2. 将FlashWalker下载到SRAM里去，从零地址开始。这里同样是直接写内存，这一步也是目前的瓶颈所在。
3. 启动FlashWalker（将PC设置为0）。烧结程序在启动后，会通过DCC通道索要烧结长度，烧结程序将用户选择的烧结数据的长度传给FlashWalker。
4. FlashWalker根据烧结长度，计算需要擦除的扇区数目，并进行擦除操作，在擦除完毕后通过DCC向烧结程序汇报擦除完毕状态。
5. 烧结程序在超时设置内收到FlashWalker汇报擦除完毕状态后，开始向DCC发送数据，因为数据长度对两方都是已知的，因此循环次数是可以确定的。如果Flash编程出现错误，FlashWalker则不再响应DCC的数据，烧结程序在超时后则可以认为编程出错。
6. 烧结程序在数据发送完毕后，等待FlashWalker反馈编程状态，通常我们编程中没有出现问题，这里就直接返回操作成功了。增加这一步是因为一个小的需求，需要在烧结完毕后复位单板，因此我们必须等待FlashWalker操作完毕。

采用DCC后，烧结时间仅为之前的20~25%，速度上有了较大的提高。


实现过程中有几个需要注意的问题。

从ARM7TDMI手册我们可以看到引脚顺序的定义与我们的输入顺序不同，我们在代码中需要进行反转，BREAKPT需要先扫描，最后才是DATA0。图6描述了代码对扫描链1的特殊处理。上图是反序前数据，下图是反序后数据。JTAG链移位是按照箭头所示的方向进行。

![JTAG扫描链1移入顺序及反转](/posts/assets/arm-jtag-6.png)

图6：JTAG扫描链1移入顺序及反转

在介绍烧结流程时我们提到了目前存在的一个瓶颈，就是将FlashWalker下载到ARM的SRAM过程，由于是用的内存写操作，因此速度较慢，如果需要，这个速度是可以再提高的。当然在烧结版本时，这个瓶颈则并不那么明显。

既然已知DCC的传递比直接写内存快，那么我们应该更多地利用DCC来传递数据。目前我们的FlashWalker包含了Flash读写操作，大小在1~2k之间，将FlashWalker写入SRAM就需要十几秒的时间，提高速度也就是再进一步降低FlashWalker的大小。我们可以将loader.s与FlashWalker.c两个部分分离，以汇编方式实现一个从DCC取FlashWalker的流程，然后由loader.s跳转到FlashWalker.c处执行Flash烧结的流程。

在使用新的DCC通道传递数据后，烧结的速度是可以接受的，250k的数据烧结，大约需要90秒时间，这个速度与HJTAG相比，还有一定的距离，有待进一步的完善与优化。
